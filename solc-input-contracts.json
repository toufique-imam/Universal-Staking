{
    "language": "Solidity",
    "sources": {
        "./contracts/StakingContractFlattened.sol": {
            "content": "// Sources flattened with hardhat v2.17.3 https://hardhat.org\n\n// SPDX-License-Identifier: MIT\n\n// File @openzeppelin/contracts/utils/Context.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\n// File @openzeppelin/contracts/access/Ownable.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n\n// File @openzeppelin/contracts/interfaces/IERC20.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\n\n// File @openzeppelin/contracts/interfaces/IERC721.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n\n// File @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\n// File @openzeppelin/contracts/interfaces/IERC721Receiver.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n\n// File @openzeppelin/contracts/security/Pausable.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n\n\n// File contracts/StakingContract.sol\n\n// Original license: SPDX_License_Identifier: MIT\npragma solidity ^0.8.0;\n\n\n\n\n\n\ncontract StakingContract is\n    Ownable,\n    Pausable,\n    ReentrancyGuard,\n    IERC721Receiver\n{\n    // Structure to represent staking pools\n    uint256 stakingFeePercentageDenominator = 1;\n    uint256 stakingFeePercentageNumerator = 100;\n    uint256 unstakingFeePercentageDenominator = 2;\n    uint256 unstakingFeePercentageNumerator = 100;\n    uint256 poolCreationFee = 0.001 ether;\n\n    struct StakingPool {\n        address stakingAddress;\n        IERC20 rewardToken;\n        uint256 stakingTokenDecimals;\n        uint256 rewardTokenDecimals;\n        uint256 rewardTokenAmount;\n        uint256 totalStaked;\n        uint256 startDate;\n        uint256 endDate;\n        address creator;\n        uint256 maxStakePerWallet;\n        bool isActive;\n        bool isNFT;\n        bool isSharedPool;\n        uint256 penaltyPercentageNumerator;\n        uint256 penaltyPercentageDenominator;\n        uint256 bonusPercentageNumerator;\n        uint256 bonusPercentageDenominator;\n        uint256 poolPeriod;\n    }\n    struct Stake {\n        uint256 poolId;\n        uint256 tokenId;\n        uint256 timestamp;\n        address owner;\n    }\n    enum ClaimState {\n        STAKE,\n        UNSTAKE,\n        CLAIM\n    }\n\n    // Mapping to track staking pools\n    mapping(uint256 => StakingPool) public stakingPools;\n\n    //mapping nft token id to stake\n    mapping(address => mapping(uint256 => Stake)) public vaults;\n    //for nft, staking address => token id => stake\n    // for token, user => poolId => stake and tokenID = token amount\n\n    uint256 public poolCount;\n\n    // Mapping to track user staked balances\n    mapping(address => mapping(uint256 => uint256)) public stakedBalances;\n    mapping(address => uint256) public tokenWithdrawBalances;\n\n    event PoolCreated(uint256 poolId);\n    event PoolStatusChanged(uint256 poolId, bool status);\n    event Staked(address indexed user, uint256 indexed poolId, uint256 amount);\n    event NFTStaked(address owner, uint256 poolId, uint256 tokenId);\n    event NFTUnstaked(address owner, uint256 poolId, uint256 tokenId);\n    event Unstaked(\n        address indexed user,\n        uint256 indexed poolId,\n        uint256 amount,\n        uint256 penalty\n    );\n    event RewardClaimed(\n        address indexed user,\n        uint256 indexed poolId,\n        uint256 amount\n    );\n\n    constructor() {}\n\n    /**\n     * @dev Function to create a new staking pool, pool creator pays a fee to create the pool\n     * @param _stakingAddress address of the staking token/nft\n     * @param _rewardTokenAddress address of the reward token\n     * @param _startDate start date of the staking period\n     * @param _endDate end date of the staking period\n     * @param _maxStakePerWallet maximum amount of tokens/nft that can be staked per wallet\n     * @param isNFT true if the pool is for NFTs\n     * @param isSharedPool true if the pool is shared\n     * @param penaltyPercentageN penalty Numerator for early unstaking\n     * @param penaltyPercentageD penalty Denominator for early unstaking\n     * @param bonusPercentageN bonus Numerator for shared pool\n     * @param bonusPercentageD bonus Denominator for shared pool\n     * @param poolPeriod pool period in seconds\n     */\n    function createStakingPool(\n        address _stakingAddress,\n        address _rewardTokenAddress,\n        uint256 _stakingTokenDecimals,\n        uint256 _rewardTokenDecimals,\n        uint256 _startDate,\n        uint256 _endDate,\n        uint256 _maxStakePerWallet,\n        bool isNFT,\n        bool isSharedPool,\n        uint256 penaltyPercentageN,\n        uint256 penaltyPercentageD,\n        uint256 bonusPercentageN,\n        uint256 bonusPercentageD,\n        uint256 poolPeriod\n    ) external payable whenNotPaused nonReentrant {\n        require(msg.value >= poolCreationFee, \"Insufficient fee\");\n        require(\n            _stakingAddress != address(0),\n            \"Staking address cannot be zero address\"\n        );\n        require(\n            _rewardTokenAddress != address(0),\n            \"Reward token address cannot be zero address\"\n        );\n        require(\n            _startDate > block.timestamp,\n            \"Start date cannot be in the past\"\n        );\n        require(_endDate > _startDate, \"End date cannot be before start date\");\n        require(\n            _maxStakePerWallet > 0,\n            \"Maximum stake per wallet cannot be zero\"\n        );\n        require(\n            penaltyPercentageN < penaltyPercentageD,\n            \"Penalty Numerator cannot be greater than Denominator\"\n        );\n        require(\n            bonusPercentageN < bonusPercentageD,\n            \"Bonus Numerator cannot be greater than Denominator\"\n        );\n        require(poolPeriod > 0, \"Pool period cannot be zero\");\n\n        uint256 poolId = poolCount;\n        stakingPools[poolId] = StakingPool(\n            _stakingAddress,\n            IERC20(_rewardTokenAddress),\n            _stakingTokenDecimals,\n            _rewardTokenDecimals,\n            0,\n            0,\n            _startDate,\n            _endDate,\n            msg.sender,\n            _maxStakePerWallet,\n            true,\n            isNFT,\n            isSharedPool,\n            penaltyPercentageN,\n            penaltyPercentageD,\n            bonusPercentageN,\n            bonusPercentageD,\n            poolPeriod\n        );\n        // isActivePool[poolId] = true;\n        poolCount++;\n\n        emit PoolCreated(poolId);\n    }\n\n    /**\n     * @dev Function for users to stake tokens\n     * @param _poolId pool id to stake in\n     * @param amount amount of tokens to stake\n     */\n    function depositRewardToken(\n        uint256 _poolId,\n        uint256 amount\n    ) public nonReentrant {\n        StakingPool storage pool = stakingPools[_poolId];\n        // Check if the pool is active\n        require(pool.isActive, \"This pool is not active\");\n        // Check if the staking period is valid\n        require(\n            block.timestamp <= pool.endDate,\n            \"Staking Ended, cannot stake.\"\n        );\n        require(amount > 0, \"Amount cannot be zero\");\n        require(msg.sender == pool.creator, \"Only creator can deposit tokens\");\n        // Make sure to approve the contract to spend the tokens beforehand\n        require(\n            pool.rewardToken.allowance(msg.sender, address(this)) >= amount,\n            \"Please approve the contract to spend the tokens first\"\n        );\n        // Transfer staking tokens from the user to the contract\n        pool.rewardToken.transferFrom(msg.sender, address(this), amount);\n        pool.rewardTokenAmount += amount;\n    }\n\n    /**\n     * @dev Function for users to stake tokens\n     * @param _poolId pool id to stake in\n     * @param _amount amount of tokens to stake\n     */\n    function stakeToken(\n        uint256 _poolId,\n        uint256 _amount\n    ) public whenNotPaused nonReentrant {\n        StakingPool memory pool = stakingPools[_poolId];\n        // Check if the pool is active\n        require(pool.isActive, \"This pool is not active\");\n        // Check if the pool is not NFT\n        require(!pool.isNFT, \"This function is for Tokens only\");\n        // Check if the staking period is valid\n        require(\n            block.timestamp >= pool.startDate &&\n                block.timestamp <= pool.endDate,\n            \"The pool isn't active yet.\"\n        );\n        // Check if the pool has any reward tokens\n        require(pool.rewardTokenAmount > 0, \"No reward token in the pool\");\n        // Check if the user's staked balance doesn't exceed the maximum allowed\n        require(\n            stakedBalances[msg.sender][_poolId] + _amount <=\n                pool.maxStakePerWallet,\n            \"Maximum Stake Limit exceeded.\"\n        );\n        // Make sure to approve the contract to spend the tokens beforehand\n        require(\n            IERC20(pool.stakingAddress).allowance(msg.sender, address(this)) >=\n                _amount,\n            \"Please approve the contract to spend the tokens first\"\n        );\n\n        //claim unclaim rewards if any\n        if (stakedBalances[msg.sender][_poolId] > 0) {\n            _claimToken(\n                _poolId,\n                msg.sender,\n                stakedBalances[msg.sender][_poolId],\n                ClaimState.STAKE\n            );\n        }\n\n        // Transfer staking tokens from the user to the contract\n        IERC20(pool.stakingAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        // Calculate staking fee\n        uint256 stakingFee = (_amount * stakingFeePercentageNumerator) /\n            stakingFeePercentageDenominator;\n\n        // update token withdraw balance\n        tokenWithdrawBalances[pool.stakingAddress] += stakingFee;\n\n        // Calculate net staked amount\n        uint256 netStakedAmount = _amount - stakingFee;\n\n        // Update user's staked balance\n        stakedBalances[msg.sender][_poolId] += netStakedAmount;\n        stakingPools[_poolId].totalStaked += netStakedAmount;\n        // Update total staked tokens in the pool\n        uint256 totalUserStaked = stakedBalances[msg.sender][_poolId];\n        // Update user's vault\n        vaults[msg.sender][_poolId] = Stake({\n            poolId: _poolId,\n            tokenId: totalUserStaked,\n            timestamp: block.timestamp,\n            owner: msg.sender\n        });\n\n        // Emit stake event\n        emit Staked(msg.sender, _poolId, _amount);\n    }\n\n    /**\n     * @dev Function for users to stake NFTs\n     * @param _poolId pool id to stake in\n     * @param tokenIds Array of token ids to stake\n     */\n    function stakeNFT(\n        uint256 _poolId,\n        uint256[] calldata tokenIds\n    ) public whenNotPaused nonReentrant {\n        StakingPool memory pool = stakingPools[_poolId];\n        // Check if the pool is active\n        require(pool.isActive, \"This pool is not active\");\n        // Check if the pool is NFT\n        require(pool.isNFT, \"This function is for NFT stake only\");\n        // Check if the staking period is valid\n        require(\n            block.timestamp >= pool.startDate &&\n                block.timestamp <= pool.endDate,\n            \"The pool isn't active yet.\"\n        );\n        // Check if the pool has any reward tokens\n        require(pool.rewardTokenAmount > 0, \"No reward token in the pool\");\n        require(tokenIds.length > 0, \"No NFT token to stake\");\n\n        // Check if the user's staked balance doesn't exceed the maximum allowed\n        require(\n            stakedBalances[msg.sender][_poolId] + tokenIds.length <=\n                pool.maxStakePerWallet,\n            \"Maximum Stake Limit exceeded.\"\n        );\n\n        IERC721 nft = IERC721(pool.stakingAddress);\n        uint256 tokenId;\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n            // check if token is owned by user\n            require(nft.ownerOf(tokenId) == msg.sender, \"not your token\");\n            // check if token is approved\n            require(nft.getApproved(tokenId) == address(this), \"not approved\");\n            // check if token is not already staked\n            require(\n                vaults[pool.stakingAddress][tokenId].tokenId == 0,\n                \"already staked\"\n            );\n            // Transfer staking tokens from the user to the contract\n            nft.safeTransferFrom(msg.sender, address(this), tokenId);\n            // Update user's staked balance\n            vaults[pool.stakingAddress][tokenId] = Stake({\n                poolId: _poolId,\n                tokenId: tokenId,\n                timestamp: block.timestamp,\n                owner: msg.sender\n            });\n            emit NFTStaked(msg.sender, _poolId, tokenId);\n        }\n        // Update total staked tokens in the pool\n        stakedBalances[msg.sender][_poolId] += tokenIds.length;\n        stakingPools[_poolId].totalStaked += tokenIds.length;\n    }\n\n    /**\n     * @dev Function for users to unstake tokens\n     * @param _poolId pool id to unstake from\n     * @param _amount amount of tokens to unstake\n     */\n    function unstakeToken(\n        uint256 _poolId,\n        uint256 _amount\n    ) external whenNotPaused nonReentrant {\n        _claimToken(_poolId, msg.sender, _amount, ClaimState.UNSTAKE);\n    }\n\n    /**\n     * @dev Function for users to claim reward tokens\n     * @param _poolId pool id to claim rewards from\n     */\n    function claimToken(uint256 _poolId) external nonReentrant whenNotPaused {\n        // claim all rewards\n        _claimToken(\n            _poolId,\n            msg.sender,\n            stakedBalances[msg.sender][_poolId],\n            ClaimState.CLAIM\n        );\n    }\n\n    /**\n     * @dev Internal Function to unstake tokens\n     * @param _poolId pool id to unstake from\n     * @param account address of the user\n     * @param _amount amount of tokens to unstake\n     */\n    function _unstakeToken(\n        uint256 _poolId,\n        address account,\n        uint256 _amount\n    ) internal {\n        StakingPool memory pool = stakingPools[_poolId];\n        // Check if the pool is active\n        // require(pool.isActive, \"This pool is not active\"); // adding this check will prevent users from unstaking after the pool is set inactive\n\n        // Check if the user has enough staked tokens\n        require(\n            stakedBalances[account][_poolId] >= _amount,\n            \"Insufficient staked balance\"\n        );\n        // Check if the staking period is valid\n        require(\n            block.timestamp >= pool.startDate,\n            \"Unstaking is not allowed before the staking period starts\"\n        );\n        // Calculate unstaking fee\n        uint256 unstakingFee = (_amount * unstakingFeePercentageNumerator) /\n            unstakingFeePercentageDenominator;\n        // Calculate penalty for early unstaking\n        uint256 penalty = 0;\n        if (block.timestamp < pool.endDate) {\n            penalty =\n                (_amount * pool.penaltyPercentageNumerator) /\n                pool.penaltyPercentageDenominator;\n        }\n        // Calculate net unstaked amount\n        uint256 netUnstakedAmount = _amount - unstakingFee - penalty;\n        // update token withdraw balance\n        tokenWithdrawBalances[pool.stakingAddress] += unstakingFee + penalty;\n\n        // Transfer staking tokens back to the user\n        IERC20(pool.stakingAddress).transfer(msg.sender, netUnstakedAmount);\n        // Update user's staked balance\n        stakedBalances[account][_poolId] -= _amount;\n        stakingPools[_poolId].totalStaked -= _amount;\n        // update vault\n        vaults[account][_poolId] = Stake({\n            poolId: _poolId,\n            tokenId: stakedBalances[account][_poolId],\n            timestamp: block.timestamp, // update timestamp to current time\n            owner: account\n        });\n        emit Unstaked(account, _poolId, _amount, penalty);\n    }\n\n    /**\n     * @dev Internal Function to claim reward tokens\n     * @param _poolId pool id to claim rewards from\n     * @param account address of the user\n     * @param _amount amount of tokens to unstake\n     * @param state -1 if no check, 0 if claim only, 1 if unstake + claim\n     */\n    function _claimToken(\n        uint256 _poolId,\n        address account,\n        uint256 _amount,\n        ClaimState state\n    ) internal {\n        StakingPool memory pool = stakingPools[_poolId];\n        // Check if the pool is active\n        // require(pool.isActive, \"This pool is not active\"); adding this check will prevent users from claiming rewards after the pool is set inactive\n        // Check if the pool is not NFT\n        require(!pool.isNFT, \"This function is for Tokens only\");\n        require(\n            block.timestamp >= pool.startDate,\n            \"Claiming is not allowed before the staking period starts\"\n        );\n        Stake memory staked = vaults[account][_poolId];\n        if(staked.timestamp >= pool.endDate){\n            //already claimed\n            if (state == ClaimState.UNSTAKE) {\n                // unstake tokens if user wants to unstake\n                _unstakeToken(_poolId, account, _amount);\n            }\n            return;\n        }\n        require(staked.timestamp < pool.endDate, \"Already claimed\");\n        // Check if the user has staked tokens\n        if (staked.owner == address(0) || staked.tokenId == 0) return;\n\n        // Calculate earned reward tokens\n        uint256 earned = 0;\n        uint256 _tokenAmountInRewardDecimals = convertAmountToDecimal(\n            staked.tokenId,\n            pool.stakingTokenDecimals,\n            pool.rewardTokenDecimals\n        );\n        uint256 _periodStaked;\n        {\n            if (block.timestamp < pool.endDate)\n                _periodStaked =\n                    (block.timestamp - staked.timestamp) /\n                    pool.poolPeriod;\n            else\n                _periodStaked =\n                    (pool.endDate - staked.timestamp) /\n                    pool.poolPeriod;\n        }\n        if (pool.isSharedPool) {\n            //reward tokens distributed based on total reward tokens and amount staked\n            uint256 totalStakeAmountInRewardDecimals = convertAmountToDecimal(\n                pool.totalStaked,\n                pool.stakingTokenDecimals,\n                pool.rewardTokenDecimals\n            );\n            earned =\n                (_tokenAmountInRewardDecimals *\n                    pool.poolPeriod *\n                    pool.rewardTokenAmount *\n                    _periodStaked) /\n                (totalStakeAmountInRewardDecimals *\n                    (pool.endDate - pool.startDate));\n        } else {\n            //reward tokens distributed based on bonus percentage and amount staked\n            earned =\n                _tokenAmountInRewardDecimals *\n                pool.bonusPercentageNumerator *\n                _periodStaked;\n            earned = earned / pool.bonusPercentageDenominator;\n        }\n        //if user want to unstake with reward 0 fall through\n        //if user is staking but earned amount is 0 fall through\n        //if user wants to claim but his amount isn't 0 fail\n        require(state == ClaimState.UNSTAKE || state == ClaimState.STAKE || earned > 0, \"nothing to unstake or claim\");\n        // update vault\n        vaults[account][_poolId] = Stake({\n            poolId: _poolId,\n            tokenId: staked.tokenId,\n            timestamp: block.timestamp, // update timestamp to current time\n            owner: account\n        });\n\n        // transfer reward tokens to user\n        if (earned > 0) {\n            require(\n                pool.rewardTokenAmount >= earned,\n                \"Not enough reward tokens in the pool\"\n            );\n            pool.rewardToken.transfer(account, earned);\n            stakingPools[_poolId].rewardTokenAmount -= earned;\n        }\n        if (ClaimState.UNSTAKE == state) {\n            // unstake tokens if user wants to unstake\n            _unstakeToken(_poolId, account, _amount);\n        }\n        emit RewardClaimed(account, _poolId, earned);\n    }\n\n    /**\n     * @dev Function for users to unstake NFTs\n     * @param _poolId pool id to unstake from\n     * @param tokenIds Array of token ids to unstake\n     */\n    function unstakeNFT(\n        uint256 _poolId,\n        uint256[] calldata tokenIds\n    ) external nonReentrant whenNotPaused {\n        _claimNFT(_poolId, msg.sender, tokenIds, true);\n    }\n\n    /**\n     * @dev Function for users to claim reward tokens\n     * @param _poolId Pool id to claim rewards from\n     * @param tokenIds Array of token ids to claim rewards from\n     */\n    function claimNFT(\n        uint256 _poolId,\n        uint256[] calldata tokenIds\n    ) external nonReentrant whenNotPaused {\n        _claimNFT(_poolId, msg.sender, tokenIds, false);\n    }\n\n    /**\n     * @dev Internal Function to unstake NFTs\n     * @param _poolId pool id to unstake from\n     * @param account address of the user\n     * @param tokenIds Array of token ids to unstake\n     */\n    function _unstakeNFT(\n        uint256 _poolId,\n        address account,\n        uint256[] calldata tokenIds\n    ) internal {\n        uint256 tokenId;\n        StakingPool memory pool = stakingPools[_poolId];\n        // require(pool.isActive, \"This pool is not active\"); // adding this check will prevent users from unstaking after the pool is set inactive\n        require(pool.isNFT, \"This function is for NFT stake only\");\n        require(\n            block.timestamp >= pool.startDate,\n            \"Unstaking is not allowed before the staking period starts\"\n        );\n        // update total staked tokens in the pool\n        stakingPools[_poolId].totalStaked -= tokenIds.length;\n        // update user's staked balance\n        stakedBalances[account][_poolId] -= tokenIds.length;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n            Stake memory staked = vaults[pool.stakingAddress][tokenId];\n            require(staked.owner == account, \"not an owner\");\n\n            delete vaults[pool.stakingAddress][tokenId];\n\n            // Transfer staking tokens back to the user\n            IERC721(pool.stakingAddress).safeTransferFrom(\n                address(this),\n                account,\n                tokenId\n            );\n            emit NFTUnstaked(account, _poolId, tokenId);\n        }\n    }\n\n    /**\n     * @dev Internal Function to claim reward tokens\n     * @param _poolId pool id to claim rewards from\n     * @param account address of the user\n     * @param tokenIds Array of token ids to claim rewards from\n     * @param _unstake true if user wants to unstake\n     */\n    function _claimNFT(\n        uint256 _poolId,\n        address account,\n        uint256[] calldata tokenIds,\n        bool _unstake\n    ) internal {\n        StakingPool memory pool = stakingPools[_poolId];\n        // require(pool.isActive, \"This pool is not active\"); // adding this check will prevent users from claiming rewards after the pool is set inactive\n        require(pool.isNFT, \"This function is for NFT stake only\");\n        require(\n            block.timestamp >= pool.startDate,\n            \"Claiming is not allowed before the staking period starts\"\n        );\n        uint256 tokenId;\n        uint256 earned = 0;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n            Stake memory staked = vaults[pool.stakingAddress][tokenId];\n            require(staked.owner == account, \"not an owner\");\n            if (staked.timestamp > pool.endDate) continue; // already claimed\n\n            uint256 _periodStaked;\n            {\n                if (block.timestamp < pool.endDate)\n                    _periodStaked =\n                        (block.timestamp - staked.timestamp) /\n                        pool.poolPeriod;\n                else\n                    _periodStaked =\n                        (pool.endDate - staked.timestamp) /\n                        pool.poolPeriod;\n            }\n            if (!pool.isSharedPool) {\n                // uint256 rewardsPerStakedAmount = totalPoolRewardPerPeriod / pool.totalStaked;\n                earned =\n                    earned +\n                    (pool.poolPeriod * pool.rewardTokenAmount * _periodStaked) /\n                    (pool.totalStaked * (pool.endDate - pool.startDate));\n            } else {\n                // reward tokens distributed based on bonus percentage and amount staked\n                earned =\n                    earned +\n                    (pool.bonusPercentageNumerator * _periodStaked) /\n                    pool.bonusPercentageDenominator;\n            }\n            vaults[pool.stakingAddress][tokenId] = Stake({\n                poolId: _poolId,\n                tokenId: tokenId,\n                timestamp: block.timestamp, // update timestamp to current time\n                owner: account\n            });\n        }\n        uint256 penaltyFee = 0;\n        uint256 unstakingFee = 0;\n        if (_unstake) {\n            // calculate penalty\n            if (pool.endDate < block.timestamp) {\n                penaltyFee =\n                    (earned * pool.penaltyPercentageNumerator) /\n                    pool.penaltyPercentageDenominator;\n            }\n            // calculate unstaking fee\n            unstakingFee =\n                (earned * unstakingFeePercentageNumerator) /\n                unstakingFeePercentageDenominator;\n            tokenWithdrawBalances[address(pool.rewardToken)] +=\n                penaltyFee +\n                unstakingFee;\n        }\n        // calculate net earned amount\n        earned = earned - penaltyFee - unstakingFee;\n        // if _unstaking then earning can be zero\n        require(_unstake || earned > 0, \"nothing to unstake or claim\");\n        if (earned > 0) {\n            require(\n                pool.rewardTokenAmount >= earned,\n                \"Not enough reward tokens in the pool\"\n            );\n            pool.rewardToken.transfer(account, earned);\n\n            stakingPools[_poolId].rewardTokenAmount -= earned;\n        }\n        if (_unstake) {\n            _unstakeNFT(_poolId, account, tokenIds);\n        }\n        emit RewardClaimed(account, _poolId, earned);\n    }\n\n    /**\n     * @dev Function to convert amount to decimal\n     * @param amount amount to convert\n     * @param currentDecimals current decimals of the token\n     * @param targetDecimals target decimals of the token\n     */\n    function convertAmountToDecimal(\n        uint256 amount,\n        uint256 currentDecimals,\n        uint256 targetDecimals\n    ) public pure returns (uint256) {\n        if (currentDecimals == targetDecimals) return amount;\n        return (amount * (10 ** targetDecimals)) / (10 ** currentDecimals);\n    }\n\n    /**\n     * @dev Function to check if a pool exists\n     * @param _poolId pool id\n     * @return bool true if pool exists, false otherwise\n     */\n    function poolExists(uint256 _poolId) external view returns (bool) {\n        return _poolId < poolCount;\n    }\n\n    /**\n     * @dev Function to check if a pool is active\n     * @param _poolId pool id\n     * @return bool true if pool is active, false otherwise\n     */\n    function poolIsActive(uint256 _poolId) external view returns (bool) {\n        return\n            stakingPools[_poolId].isActive &&\n            block.timestamp >= stakingPools[_poolId].startDate &&\n            block.timestamp <= stakingPools[_poolId].endDate;\n    }\n\n    /**\n     * @dev Function to get pool info\n     * @param _poolId pool id\n     * @return StakingPool struct\n     */\n    function getPoolInfo(\n        uint256 _poolId\n    ) external view returns (StakingPool memory) {\n        return stakingPools[_poolId];\n    }\n\n    /**\n     * @dev Function to get user's reward info for staked nfts\n     * @param _poolId pool id\n     * @param tokenIds array of token ids\n     */\n    function earningInfoNFT(\n        uint256 _poolId,\n        uint256[] calldata tokenIds\n    ) public view returns (uint256) {\n        uint256 tokenId;\n        uint256 earned = 0;\n        StakingPool memory pool = stakingPools[_poolId];\n        if (pool.isNFT == false) return earned;\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            tokenId = tokenIds[i];\n            Stake memory staked = vaults[pool.stakingAddress][tokenId];\n            if (staked.timestamp > pool.endDate) continue; // already claimed\n\n            uint256 _periodStaked;\n            {\n                if (block.timestamp < pool.endDate)\n                    _periodStaked =\n                        (block.timestamp - staked.timestamp) /\n                        pool.poolPeriod;\n                else\n                    _periodStaked =\n                        (pool.endDate - staked.timestamp) /\n                        pool.poolPeriod;\n            }\n            if (!pool.isSharedPool) {\n                // uint256 rewardsPerStakedAmount = totalPoolRewardPerPeriod / pool.totalStaked;\n                earned =\n                    earned +\n                    (pool.poolPeriod * pool.rewardTokenAmount * _periodStaked) /\n                    (pool.totalStaked * (pool.endDate - pool.startDate));\n            } else {\n                // reward tokens distributed based on bonus percentage and amount staked\n                earned =\n                    earned +\n                    (pool.bonusPercentageNumerator * _periodStaked) /\n                    pool.bonusPercentageDenominator;\n            }\n        }\n        return earned;\n    }\n\n    /**\n     * @dev Function to get user's reward info for staked tokens\n     * @param _poolId pool id\n     * @param account address of the user\n     */\n    function earningInfoToken(\n        uint256 _poolId,\n        address account\n    ) public view returns (uint256) {\n        uint256 earned = 0;\n        StakingPool memory pool = stakingPools[_poolId];\n        if (pool.isNFT == true) return earned;\n        Stake memory staked = vaults[account][_poolId];\n        if (staked.timestamp > pool.endDate) return earned; // already claimed\n        uint256 _tokenAmountInRewardDecimals = convertAmountToDecimal(\n            staked.tokenId,\n            pool.stakingTokenDecimals,\n            pool.rewardTokenDecimals\n        );\n        uint256 _periodStaked;\n        {\n            if (block.timestamp < pool.endDate)\n                _periodStaked =\n                    (block.timestamp - staked.timestamp) /\n                    pool.poolPeriod;\n            else\n                _periodStaked =\n                    (pool.endDate - staked.timestamp) /\n                    pool.poolPeriod;\n        }\n        if (pool.isSharedPool) {\n            //reward tokens distributed based on total reward tokens and amount staked\n            uint256 totalStakeAmountInRewardDecimals = convertAmountToDecimal(\n                pool.totalStaked,\n                pool.stakingTokenDecimals,\n                pool.rewardTokenDecimals\n            );\n            earned =\n                (_tokenAmountInRewardDecimals *\n                    pool.poolPeriod *\n                    pool.rewardTokenAmount *\n                    _periodStaked) /\n                (totalStakeAmountInRewardDecimals *\n                    (pool.endDate - pool.startDate));\n        } else {\n            //reward tokens distributed based on bonus percentage and amount staked\n            earned =\n                _tokenAmountInRewardDecimals *\n                pool.bonusPercentageNumerator *\n                _periodStaked;\n            earned = earned / pool.bonusPercentageDenominator;\n        }\n        return earned;\n    }\n\n    /**\n     * @dev Changes pool status, can only be called by the creator of the pool.\n     * @param _poolId pool id\n     * @param status true for active and false for inactive\n     */\n    function setPoolisActiveStatus(uint256 _poolId, bool status) external nonReentrant {\n        StakingPool storage pool = stakingPools[_poolId];\n        require(\n            pool.creator == msg.sender,\n            \"Only creator can change pool status\"\n        );\n        require(pool.isActive != status, \"Pool is already in the same state\");\n        pool.isActive = status;\n        emit PoolStatusChanged(_poolId, status);\n    }\n\n    /**\n     * @dev withdraws reward tokens from contract, can only be called by the creator of the pool.\n     * @param _poolId pool id\n     */\n    function WithdrawRWDcreator(uint256 _poolId) external nonReentrant {\n        StakingPool storage pool = stakingPools[_poolId];\n        require(pool.creator == msg.sender, \"Only creator can withdraw\");\n        require(\n            pool.isActive == false || pool.endDate < block.timestamp,\n            \"Pool is active or not ended yet\"\n        );\n        pool.rewardToken.transfer(msg.sender, pool.rewardTokenAmount);\n        pool.rewardTokenAmount = 0;\n    }\n\n    /**\n     * @dev Withdraws ERC20 tokens from contract, can only be called by the owner.\n     * can be used to withdraw staking and reward tokens\n     * amount of token to withdraw is tracked in tokenWithdrawBalances mapping\n     * @param token address of token to withdraw\n     */\n    function withdrawToken(address token) external onlyOwner nonReentrant {\n        uint256 amount = tokenWithdrawBalances[token];\n        require(amount > 0, \"No token to withdraw\");\n        IERC20(token).transfer(msg.sender, amount);\n        tokenWithdrawBalances[token] = 0;\n    }\n\n    /**\n     * @dev Withdraws ETH from contract, can only be called by the owner.\n     */\n    function withdraw() external onlyOwner nonReentrant {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /**\n     * @dev pause and unpause contract, can only be called by the owner.\n     * @param state true for pause and false for unpause\n     */\n    function changeContractState(bool state) external onlyOwner {\n        if (state == true) _pause();\n        else _unpause();\n    }\n\n    /**\n     * @dev function to receive ERC721 tokens, when safeTransferFrom is called on ERC721 contract\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return\n            IERC721Receiver.onERC721Received.selector ^ this.stakeNFT.selector;\n    }\n\n    /**\n     * @dev set staking fee percentage, can only be called by the owner.\n     * @param _stakingFeePercentageN Staking fee percentage nominator\n     * @param _stakingFeePercentageD Staking fee percentage dominator\n     */\n    function setStakingFeePercentage(\n        uint256 _stakingFeePercentageN,\n        uint256 _stakingFeePercentageD\n    ) external onlyOwner {\n        require(\n            _stakingFeePercentageN < _stakingFeePercentageD,\n            \"Invalid staking fee percentage\"\n        );\n        stakingFeePercentageNumerator = _stakingFeePercentageN;\n        stakingFeePercentageDenominator = _stakingFeePercentageD;\n    }\n\n    /**\n     * @dev set unstaking fee percentage, can only be called by the owner.\n     * @param _unstakingFeePercentageN Unstaking fee percentage nominator\n     * @param _unstakingFeePercentageD Unstaking fee percentage dominator\n     */\n    function setUnstakingFeePercentage(\n        uint256 _unstakingFeePercentageN,\n        uint256 _unstakingFeePercentageD\n    ) external onlyOwner {\n        require(\n            _unstakingFeePercentageN < _unstakingFeePercentageD,\n            \"Invalid unstaking fee percentage\"\n        );\n        unstakingFeePercentageNumerator = _unstakingFeePercentageN;\n        unstakingFeePercentageDenominator = _unstakingFeePercentageD;\n    }\n\n    function getStakingFeePercentage()\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return (stakingFeePercentageNumerator, stakingFeePercentageDenominator);\n    }\n\n    function getUnstakingFeePercentage()\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            unstakingFeePercentageNumerator,\n            unstakingFeePercentageDenominator\n        );\n    }\n\n    function setPoolCreationFee(uint256 _poolCreationFee) external onlyOwner {\n        poolCreationFee = _poolCreationFee;\n    }\n\n    function getPoolCreationFee() external view returns (uint256) {\n        return poolCreationFee;\n    }\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "viaIR": true,
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}